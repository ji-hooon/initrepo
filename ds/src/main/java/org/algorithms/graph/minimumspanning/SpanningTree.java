package org.algorithms.graph.minimumspanning;

import org.algorithms.graph.shortestpath.WeightedGraph;

public class SpanningTree {
    //신장트리
    //: 원래의 그래프의 모든 노드가 연결되어 있고, 트리의 속성을 만족하는 그래프
    //신장 트리의 조건
    //(1) 신장 트리를 만드려는 그래프의 모든 노드를 포함한다.
    //(2) 해당 그래프의 모든 노드가 서로 연결되어 있는 상태여야 한다.
    //(3) 사이클이 존재하지 않는 트리의 속성을 만족해야 한다.

    //최소신장트리 MST (Minimum Spanning Tree)
    //: 가중치가 있는 일반적으로 무방향 그래프에서 그래프의 여러개의 신장트리 중 간선의 가중치 합이 최소인 신장 트리
    //최소신장트리를 구하는 알고리즘

    //1-1. 크루스칼 알고리즘
    // - 탐욕 알고리즘과 Union-Find 알고리즘을 이용해 간선을 오름차순으로 정렬해 최소 가중치부터 연결하면서 구현

    //1-2. 구현하기 위해 사용하는 알고리즘의 특징
    //(1) 탐욕 알고리즘 : 현재 시점에서 최소 비용을 선택해서, 최적의 결과를 찾도록 하는 알고리즘
    //(2) Union-Find 알고리즘 : 트리 구조를 활용해 Disjoint Set을 표현하는 알고리즘으로,
    //노드들 중에 연결된 노드를 찾거나, 노드들을 서로 연결할 때 사용한다.

    //(2)-1. Disjoint Set : 서로소 집합 자료구조로, 중복되지 않는 부분 집합들로 나눠진 원소들을 저장하는 자료구조

    //(2)-2. Union-Find 알고리즘 구현 : 간선으로 연결된 두 노드의 루트 노드가 서로 다르도록 합친다.
    //(1) n개의 원소가 개별 집합이 되도록 만든다. - 초기화
    //(2) 두 개별 집합인 두 트리를 하나의 트리로 만들기 위해 하나의 집합으로 합친다. - Union
    //(3) 존재 하는 여러 노드 중 두 개의 노드를 선택,
    // 선택한 두 노드가 하나의 그래프에 속하는지 각 그룹의 최상단 원소인 루트 노드로 확인한다. - Find

    //(2)-3. 높이가 늘어나지 않도록 관리해, 효율적으로 루트 노드를 계산 하기 위한 기법
    //(1) union-by-rank 기법 : rank는 0부터 시작
    // 각 트리의 높이를 기억해 서로 다른 두 트리를 union할 때 높이가 낮은 트리를 높이가 높은 트리에 붙인다.
    //-> 높이가 큰 트리의 루트 노드가 합친 집합의 루트노드가 되도록 한다.
    //만약, 서로의 높이가 같다면 하나의 트리의 높이를 늘려서 다른 트리를 해당 트리의 루트 노드에 붙인다.

    //(2) path compression 기법  : Find 실행시에 동작
    //Find를 실행한 노드에서 거쳐간 노드를 루트노드의 자식으로 직접 연결하는 기법으로,
    //-> Find를 실행한 노드 이후의 노드들은 루트 노드를 한번에 알 수 있게 된다.


    //1-3. 크루스칼 알고리즘 구현 순서
    //(1) 모든 정점을 연결된 간선을 제거한 상태로 만든다.
    //(2) 모든 간선을 비용 기준으로 정렬해 최소 비용 간선부터 양 끝의 두 정점을 비교한다.
    //(3) 비교해 최소 비용의 간선을 선택할 때, 두 정점사이에 사이클이 존재하지 않도록 연결한다.
    //-> 따라서, 사이클이 생기지 않도록 구현하기 위해 두 정점의 Union-Find 알고리즘을 이용해 최상위 정점을 확인해 서로 다를 때만 연결한다.
    //(4) 모든 정점을 사이클 없이 연결한 경우 최소신장트리 완성

//    2. 프림 알고리즘
//    - 탐욕 알고리즘을 이용해 특정 정점의 최소 가중치인 간선부터 연결 시작하면서 구현
//    : 간선이 연결되면, 해당 정점에서 최소 가중치이고, 사이클이 생기지 않도록 하는 간선의 연결을 반복한다.
//
//    2-1. 프림 알고리즘 구현 순서
//    (1) 임의의 정점을 선택하고, 연결된 노드 집합에 삽입한다.
//    (2) 선택한 정점에 연결된 간선들을 간선 리스트에 삽입한다.
//    (3) 간선 리스트를 오름차순 정렬해 가장 최소 가중치인 간선부터 뽑는다.
//    (4) 뽑은 간선이 해당 조건을 충족하는지 확인
//    -해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 이미 들어 있다면, 사이클이 생길 수 있으므로 다음 간선을 다시 뽑는다.
//    -해당 간선에 연결된 인접 정점이 '연결된 노드 집합'에 들어 있지 않다면, 해당 간선을 선택해 최소 신장 트리에 삽입
//    (5) 선택한 간선은 간선 리스트에서 제거한다.
//    (6) 간선 리스트에 더 이상의 간선이 남아 있지 않을 때 까지 반복한다.
//

    public static class Edge implements Comparable<Edge>{
        private int weight;
        private String nodeV;
        private String nodeU;

        public Edge(int weight, String nodeV, String nodeU) {
            this.weight = weight;
            this.nodeV = nodeV;
            this.nodeU = nodeU;
        }

        public int getWeight() {
            return weight;
        }

        public String getNodeV() {
            return nodeV;
        }

        public String getNodeU() {
            return nodeU;
        }

        @Override
        public String toString() {
            return "Edge{" +
                    "weight=" + weight +
                    ", nodeV='" + nodeV + '\'' +
                    ", nodeU='" + nodeU + '\'' +
                    '}';
        }

        @Override
        //가중치 기준으로 정렬
        public int compareTo(Edge edge) {
            //오름차순
            return this.getWeight()-edge.getWeight();
        }
    }
}
